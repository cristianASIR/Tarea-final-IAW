"use strict";
<<<<<<< HEAD
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Explorer = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const path_type_1 = require("path-type");
const ExplorerBase_js_1 = require("./ExplorerBase.js");
const loaders_js_1 = require("./loaders.js");
const util_js_1 = require("./util.js");
/**
 * @internal
 */
class Explorer extends ExplorerBase_js_1.ExplorerBase {
    async load(filepath) {
        filepath = path_1.default.resolve(filepath);
        const load = async () => {
            return await this.config.transform(await this.#readConfiguration(filepath));
        };
        if (this.loadCache) {
            return await (0, util_js_1.emplace)(this.loadCache, filepath, load);
        }
        return await load();
    }
    async search(from = '') {
        if (this.config.metaConfigFilePath) {
            this.loadingMetaConfig = true;
            const config = await this.load(this.config.metaConfigFilePath);
            this.loadingMetaConfig = false;
            if (config && !config.isEmpty) {
                return config;
            }
        }
        const stopDir = path_1.default.resolve(this.config.stopDir);
        from = path_1.default.resolve(from);
        const search = async () => {
            /* istanbul ignore if -- @preserve */
            if (await (0, path_type_1.isDirectory)(from)) {
                for (const place of this.config.searchPlaces) {
                    const filepath = path_1.default.join(from, place);
                    try {
                        const result = await this.#readConfiguration(filepath);
                        if (result !== null &&
                            !(result.isEmpty && this.config.ignoreEmptySearchPlaces)) {
                            return await this.config.transform(result);
                        }
                    }
                    catch (error) {
                        if (error.code === 'ENOENT' ||
                            error.code === 'EISDIR' ||
                            error.code === 'ENOTDIR') {
                            continue;
                        }
                        throw error;
                    }
                }
            }
            const dir = path_1.default.dirname(from);
            if (from !== stopDir && from !== dir) {
                from = dir;
                if (this.searchCache) {
                    return await (0, util_js_1.emplace)(this.searchCache, from, search);
                }
                return await search();
            }
            return await this.config.transform(null);
        };
        if (this.searchCache) {
            return await (0, util_js_1.emplace)(this.searchCache, from, search);
        }
        return await search();
    }
    async #readConfiguration(filepath) {
        const contents = await promises_1.default.readFile(filepath, { encoding: 'utf-8' });
        return this.toCosmiconfigResult(filepath, await this.#loadConfiguration(filepath, contents));
    }
    async #loadConfiguration(filepath, contents) {
        if (contents.trim() === '') {
            return;
        }
        if (path_1.default.basename(filepath) === 'package.json') {
            return ((0, util_js_1.getPropertyByPath)((0, loaders_js_1.loadJson)(filepath, contents), this.config.packageProp) ?? null);
        }
        const extension = path_1.default.extname(filepath);
        try {
            const loader = this.config.loaders[extension || 'noExt'] ??
                this.config.loaders['default'];
            if (loader !== undefined) {
                // eslint-disable-next-line @typescript-eslint/return-await
                return await loader(filepath, contents);
            }
        }
        catch (error) {
            error.filepath = filepath;
            throw error;
        }
        throw new Error(`No loader specified for ${(0, ExplorerBase_js_1.getExtensionDescription)(extension)}`);
    }
}
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Explorer = void 0;

var _path = _interopRequireDefault(require("path"));

var _ExplorerBase = require("./ExplorerBase");

var _readFile = require("./readFile");

var _cacheWrapper = require("./cacheWrapper");

var _getDirectory = require("./getDirectory");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Explorer extends _ExplorerBase.ExplorerBase {
  constructor(options) {
    super(options);
  }

  async search(searchFrom = process.cwd()) {
    const startDirectory = await (0, _getDirectory.getDirectory)(searchFrom);
    const result = await this.searchFromDirectory(startDirectory);
    return result;
  }

  async searchFromDirectory(dir) {
    const absoluteDir = _path.default.resolve(process.cwd(), dir);

    const run = async () => {
      const result = await this.searchDirectory(absoluteDir);
      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);

      if (nextDir) {
        return this.searchFromDirectory(nextDir);
      }

      const transformResult = await this.config.transform(result);
      return transformResult;
    };

    if (this.searchCache) {
      return (0, _cacheWrapper.cacheWrapper)(this.searchCache, absoluteDir, run);
    }

    return run();
  }

  async searchDirectory(dir) {
    for await (const place of this.config.searchPlaces) {
      const placeResult = await this.loadSearchPlace(dir, place);

      if (this.shouldSearchStopWithResult(placeResult) === true) {
        return placeResult;
      }
    } // config not found


    return null;
  }

  async loadSearchPlace(dir, place) {
    const filepath = _path.default.join(dir, place);

    const fileContents = await (0, _readFile.readFile)(filepath);
    const result = await this.createCosmiconfigResult(filepath, fileContents);
    return result;
  }

  async loadFileContent(filepath, content) {
    if (content === null) {
      return null;
    }

    if (content.trim() === '') {
      return undefined;
    }

    const loader = this.getLoaderEntryForFile(filepath);
    const loaderResult = await loader(filepath, content);
    return loaderResult;
  }

  async createCosmiconfigResult(filepath, content) {
    const fileContent = await this.loadFileContent(filepath, content);
    const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);
    return result;
  }

  async load(filepath) {
    this.validateFilePath(filepath);

    const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);

    const runLoad = async () => {
      const fileContents = await (0, _readFile.readFile)(absoluteFilePath, {
        throwNotFound: true
      });
      const result = await this.createCosmiconfigResult(absoluteFilePath, fileContents);
      const transformResult = await this.config.transform(result);
      return transformResult;
    };

    if (this.loadCache) {
      return (0, _cacheWrapper.cacheWrapper)(this.loadCache, absoluteFilePath, runLoad);
    }

    return runLoad();
  }

}

>>>>>>> 79534482 (Base)
exports.Explorer = Explorer;
//# sourceMappingURL=Explorer.js.map